
<!DOCTYPE HTML>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Image Browser and Search</title>
		<link rel="stylesheet" href="style/style.css" media="screen">
		<link rel="stylesheet" href="style/demo.css" media="screen">
		<link rel="stylesheet" href="/dojo1.10.0src/dijit/themes/claro/claro.css" media="screen">
		<!-- load dojo and provide config via data attribute -->
		<!--
		<script src="http://ajax.googleapis.com/ajax/libs/dojo/1.10.0/dojo/dojo.js"
				data-dojo-config="isDebug: true,parseOnLoad: true">
		-->
		<script src="/dojo1.10.0src/dojo/dojo.js"
			data-dojo-config="isDebug: true,parseOnLoad: true">
		</script>
		<script>
			dojo.require("dojo.store.JsonRest");
			
			// dojo.require("dojo.store.Observable");
			dojo.require("dijit.Tree");
			dojo.require("dijit.tree.dndSource");
			dojo.require("dijit.Dialog");
			dojo.require("dijit.layout.BorderContainer");
			dojo.require("dijit.layout.AccordionContainer");
			dojo.require("dijit.layout.AccordionPane");
			dojo.require("dijit.layout.ContentPane");
			
			dojo.ready(function(){

				// Grab the list of types that have generated thumbnails.  Knowing what these are helps minimize
				// the case where the browser loads the same image under a different url, eating up memory.
				var imageTypes = [];
				var xhrArgs = {
				    url: "./rest/imageUtil/imageTypes",
				    handleAs: "json",
				    load: function(data){
				    	// convert all to lower case.  We need to be able to match them.
				    	for (var i = 0; i < data.length; i++) {
				    		imageTypes.push(data[i].toLowerCase())
				    	}
				    },
				    error: function(error){
	        			var dialog = new dijit.Dialog({title: 'Error', content: "Error is " + error});
	        			dialog.show();
				    }
				}
				// Call the asynchronous xhrGet
				var deferred = dojo.xhrGet(xhrArgs);
				
				var fileSet = dojo.store.JsonRest({
					target:"./rest/dojoSearch",
					mayHaveChildren: function(object){
						// see if it has a children property
						return ("allowsChildren" in object) && (object.allowsChildren);
					},
					getChildren: function(object, onComplete, onError){
						// retrieve the full copy of the object
						deferred = this.get(object.path);
						
						// This is what happens is the request is successful.
						var getChildrenFunction = function(fullObject){
							// copy to the original object so it has the children array as well.
							object.children = fullObject.children;
							// now that full object, we should have an array of children
							onComplete(fullObject.children);
						};

						var getChildrenErrorFunction = buildOnError(deferred, getChildrenFunction);							
						
						deferred.then(getChildrenFunction, getChildrenErrorFunction);
					},
					getRoot: function(onItem, onError){
						// get the root object, we will do a get() and callback the result
						this.get("").then(onItem, onError);
					},
					getLabel: function(object){
						// just get the name
						return object.name;
					},
					
					put: function(object, options){
						//this.onChange(object);
						this.onChildrenChange(object, object.children);
						this.onChange(object);
						return dojo.store.JsonRest.prototype.put.apply(this, arguments);
					}
				});
				tree = new dijit.Tree({
					model: fileSet
					// ,dndController: dijit.tree.dndSource
				//}, "tree"); // make sure you have a target HTML element with this id
				});
				var bc = new dijit.layout.BorderContainer({
			        style: "height: 95%; width: 95%;"
			    });
				bc.addChild(new dijit.layout.ContentPane({
					region:'left',
			        style: "height: 100%; width: 25%;",
					content:tree
				}));
				
				
				
				// I think I want this to be an accordian.
				var bc2 = new dijit.layout.AccordionContainer({
				// var bc2 = new dijit.layout.BorderContainer({
			        region: "center",
			        style: "height: 100%; width: 100%;"
			    });
			    bc.addChild(bc2);

				// create a ContentPane as the center pane in the BorderContainer
			    //var cp2 = new dijit.layout.ContentPane({
			    var cp2 = new dijit.layout.AccordionPane({			    	
			    	id: "fileDetailsID",
			        region: "center",
			        title: "Item Details",
			        content: "Click on an item in the tree to see it display here."
			    });
			    bc2.addChild(cp2);
			    // var cp3 = new dijit.layout.ContentPane({
			    var cp3 = new dijit.layout.AccordionPane({			    	
			        region: "top",
			        title: "Filter Items",
			        content: "This is where the search widget should go"
			    });
			    bc2.addChild(cp3);

				dojo.connect(tree, "onClick", function(object){
					// How about doing something like this?
				    //dijit.byId("fileDetailsID").set('href', './'+object.type + object.path);
					// this would result in paths like:
					// ./dir/Bath
					// ./png/Business Picture.png
					// So I could map the path (/dir/*, /png/*) a specific restlet.
					// not sure though, this would mean reloading.  Not sure I want that.					
					
					if('folder' == object.type)
					{
						// Display thumbnails for the images in the dir.
						// Probably want a rolling load, depending on what is showing.  Also
						// want to UNLOAD images after a certain point.
						
						// If the children are already fetched, just use them, otherwise go get them
						if(object.allowsChildren)
						{
							var displayChildren = function(children){
								var html = "<div>";
								for(var idx=0;idx<children.length;idx++){
									var child = children[idx];
									// The problem with this is that all children have their own url to their thumbnail,
									// and this prevents the browser from cacheing effectively...
									// html += '<img src="./thumbnail'+child.path+'"></img>'
									// So we need to be intelligent based on the 'type'.
									//
									// Where should this intelligence lie?  What should determine what the item icon is?
									// If it lies on the server, then the browser is crippled, and we have to transfer more 
									// data.  Do it here, but abstract it out to a common area.  This should be in a single
									// script.
									//
									// Check the type - lowercase it to match the type array
									if(-1 == imageTypes.indexOf(child.type.toLowerCase()))
									{
										html += '<img src="./thumbnail/?DEFAULT='+child.type+'"></img>'
									}
									else
									{
										// This object has a thumbnail that only belongs to it.
										html += '<img src="./thumbnail'+child.path+'"></img>'
									}
								}
								html += "</div>";
							    dijit.byId("fileDetailsID").set('content', html);
							};
							
							if(null == object.children)
							{
								tree.model.getChildren(object, 
									displayChildren, 
									function(error){
				        				var dialog = new dijit.Dialog({title: 'Error', content: myDeferred.ioArgs.xhr.responseText});
				        				dialog.show();
									}
								);
							}
							else
							{
								displayChildren(object.children);
							}
						}
					    // dijit.byId("fileDetailsID").set('content', object.path);
					}
					else
					{
						// This puts the raw metadata into the page as a string
					    //dijit.byId("fileDetailsID").set('href', './rest/imageMetaData'+object.path);
						// This puts the raw content of the image into the page as a string.  Kind of cool...
					    //dijit.byId("fileDetailsID").set('href', './image'+object.path);
						// This puts the raw content of the image thumbnail into the page as a string.  Kind of cool...
					    //dijit.byId("fileDetailsID").set('href', './thumbnail'+object.path);
						
						// This will actually display the image in the content pane.
					    dijit.byId("fileDetailsID").set(
					    		'content', '<img src="./image'+object.path+'"></img>');
						
						
	
						//dijit.byId("fileDetailsID").content = "You clicked "+object.name;
					}
				});
			    
			    // put the top level widget into the document, and then call startup()
			    bc.placeAt(document.body);
			    bc.startup();
				
// 				dojo.query("#add-new-child").onclick(function(){
// 					var selectedObject = tree.get("selectedItems")[0];
// 					if(!selectedObject){
// 						return alert("No object selected");
// 					}
// 					fileSet.get(selectedObject.id).then(function(selectedObject){
// 						selectedObject.children.push({
// 							name: "New child",
// 							id: Math.random()
// 						});
// 						fileSet.put(selectedObject);
// 					});
					
// 				});
// 				dojo.connect(tree, "onDblClick", function(object){
// 					object.name = prompt("Enter a new name for the object");
// 					fileSet.put(object);
// 				});
			});

			//------------------------------------------------------------
			// 	This is the beginning of a more generic way to deal with session timeouts
			//	in an application that uses form-based authentication.  This currently makes the 
			//	assumption that the data returned will need to be handles as 'json'.
			//
			//	'deferred' - the Promise object returned by the dojo.store.JsonRest.get command, and possibly others...
			//	'dataCallbackFunction' - the function that will be called after authentication succeeds
			//
			// 	It also makes the following assumptions about the login page:
			// 	It contains the string '3ff0f1a0-3f31-11e4-916c-0800200c9a66'
			//	The login form is named 'myform'
			function buildOnError(deferred, dataCallbackFunction)
			{
				return function(error){
					var myDeferred = deferred;
					// If the session timed out, detect it.
					// 200 is an "OK" response, but it is what comes back for the
					// form based authentication.
					if(200 == myDeferred.ioArgs.xhr.status)
					{
						// Might be a session timeout.  Will check the response text for
						// a substring that should only occur in the login challenge.
						// the value '3ff0f1a0-3f31-11e4-916c-0800200c9a66' is in the login page.
						if(myDeferred.ioArgs.xhr.responseText.indexOf('3ff0f1a0-3f31-11e4-916c-0800200c9a66') > -1)
						{
							// Create a Dialog to hold the login page.  This will make the dom element
							//	'myform' available to be modified.
			        		var dialog = new dijit.Dialog({title: 'Session Timed Out', content: myDeferred.ioArgs.xhr.responseText});
			        		
							// Rewire the 'onSubmit' to execute asynch, and take the output back to passed function
			    			function sendForm(dataCallback){
								// This is the name of the form in the login page.
			  				  	var form = dojo.byId("myform");
			  				  	dojo.connect(form, "onsubmit", 
			  				  		function(event){
			  				    		// Stop the submit event since we want to control form submission.
			  				    		dojo.stopEvent(event);

			  				    		// The parameters to pass to xhrPost, the form, how to handle it, and the callbacks.
			  				    		// Note that there isn't a url passed.  xhrPost will extract the url to call from the form's
			  				    		//'action' attribute.  
			  				    		var xhrArgs = {
			  				      			form: dojo.byId("myform"),
			  				      			handleAs: "json",
			  				      			load: function(data){
			  				      				dataCallback(data);
			  				        			dojo.byId("response").innerHTML = "Login success.";
			  				    				dialog.destroy();
			  				      			},
			  				      			error: function(error){
												// onComplete([]);
			  				        			dojo.byId("response").innerHTML = "Error: " + error;
			  				      			}
			  							}
			  							// Call the asynchronous xhrPost
			  							dojo.byId("response").innerHTML = "Sending login request..."
			  				    		var deferred = dojo.xhrPost(xhrArgs);
			  				  		}
			  				  	);
			  				}
							// Run the function above.  why is it doing things this way?  Because this will 
							// almost definately be needed elsewhere, so trying to make it generic for later
							// refactoring.
			    			sendForm(dataCallbackFunction);
			        		
			        		dialog.show();
						}
					}
					else
					{										
	        			var dialog = new dijit.Dialog({title: 'Error', content: myDeferred.ioArgs.xhr.responseText});
	        			dialog.show();
						// an error occurred, log it, and indicate no children
						console.error(error);
						// onComplete([]);
					}	        		
				};
			}
		</script>
	</head>
	<body class="claro">
		<!--h1>Demo: Connecting Tree to a Store</h1>
		<div id="tree"></div>
		<p><button id="add-new-child">Add new child to selected item</button></p -->
	</body>
</html>
